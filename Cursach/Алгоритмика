Конечно, полученное двоичное дерево весьма необычно, и специфика его проявляется еще и в том,
что адресные поля вершин имеют четкую специализацию и принципиально различаются по смыслу:
левое поле используется для адресации старшего потомка, правое – для адресации очередного брата
в списке братьев-потомков одной и той же вершины.

Полученное двоичное дерево можно реализовать стандартным образом как набор вершин-записей,
размещаемых в динамически распределяемой памяти. Это позволяет использовать для обработки
недвоичного дерева известные алгоритмы работы с двоичными деревьями. Правда, эти алгоритмы
приходится дорабатывать, чтобы учесть специфику недвоичных деревьев.

Рассмотрим кратко возможные реализации основных операций с недвоичными деревьями на базе алгоритмов обработки двоичных деревьев.

Прежде всего, надо сделать объявления, необходимые для реализации двоичной модели недвоичного дерева:

описать структуру вершин двоичного дерева с информационным полем и двумя специализированными адресными полями;
ввести основную переменную – указатель на корневую вершину двоичного дерева.
Операцию поиска заданной вершины в принципе можно реализовать на основе любого правила обхода двоичной модели.
Возможно, в большинстве задач наиболее удобным будет использование прямого обхода. Необходимо понимать, что
недвоичное дерево не является поисковым, и поэтому при поиске вполне возможна ситуация полного перебора всех вершин.
Еще одна трудность возникает при определении родителя искомой вершины, поскольку непосредственная связь с родителем
есть только у старшего потомка.

Добавление новой вершины как потомка заданной вершины включает в себя:

поиск заданной вершины;
если заданная вершина найдена, выделяется память для новой вершины и заполняются ее поля, в том числе и оба адресных нулевых поля;
если заданная вершина пока еще не имеет потомков (признак - нулевое левое адресное поле), то новая вершина становится
этим единственным потомком, для чего ее адрес заносится в левое адресное поле заданной вершины;
если заданная вершина уже имеет потомков, то через ее левое адресное поле определяется старший потомок, который является
первым элементом в списке братьев, и выполняется добавление новой вершины в этот список;
простейший вариант добавления – в начало списка сразу за старшим потомком;
для добавления в конец списка необходимо пройти по правым адресным полям всех братьев.
Удаление заданной вершины:

поиск удаляемой вершины с определением ее родителя;
если удаляемая вершина не имеет потомков (признак - пустое левое адресное поле), то возможны два случая:
удаляемая вершина не является старшим потомком и поэтому просто удаляется из списка братьев стандартным образом (используются правые адресные поля вершин) (вершины 3, 7, 8, 10, 13-15, 17-20);
удаляемая вершина – старший потомок (например 5, 9, 12, 16); здесь надо изменить адрес старшего потомка у родителя, записав в его левое адресное поле адрес следующего по порядку брата (вместо вершины 5 старшей становится вершина 6, вместо 9 – 10 и т.д.);
более сложная ситуация возникает в случае удаления вершины с потомками; возникает вопрос: что делать с этими потомками? Возможные варианты:
запретить удаление таких вершин (обычно это соглашение применяется к корневой вершине дерева);
удалить вместе с вершиной и всех его потомков, что можно сделать за счет рекурсивного обратного обхода вершин поддерева с корнем - удаляемой вершиной; после этого удаляемая вершина обрабатывается как не имеющая потомков (такое удаление можно назвать «жестким»);
передать всех потомков родителю удаляемой вершины («мягкое» удаление); в этом случае в списке братьев удаляемой вершины вместо нее появляется список ее непосредственных потомков. Здесь приходится рассматривать два подслучая – более простой, когда удаляемая вершина не является старшим потомком, и чуть более сложный – когда является (придется заменить левое адресное поле у родителя).
Как видно из этих алгоритмов, кроме операций с двоичными деревьями приходится использовать и операции с линейными списками.
